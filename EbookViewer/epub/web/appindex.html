<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <!-- <meta name="apple-mobile-web-app-capable" content="yes" /> -->
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=1, maximum-scale=3">
        <title>Syntek epub viewer</title>
        <!-- <link rel="stylesheet" type="text/css" href="examples.css"> -->
        <script src="jszpi.min.js"></script>
        <script src="../dist/epub.js"></script>
        <script src="adder.js"></script>
        <script src="api-connect.js"></script>
        <link rel="stylesheet" type="text/css" href="fonts.css">
        <link rel="stylesheet" type="text/css" href="app-common.css">
        <style type="text/css">
    #viewer.page {
      width: 100vw;
      height: 100vh;
      min-width: 100vw;
      min-height: 100vh;
      padding: 0;
      position: relative;
      top: 0;
      overflow: hidden;
    }

    #viewer.page * {
      overflow: hidden;
    }

    body *::-webkit-scrollbar {
      display: none;
    }

    #viewer.scroll {
      width: 100vw;
      height: 100vh;
      /* overflow: auto; */
      margin: 0 auto;
    }

    .epub-container {
      overscroll-behavior: none;
      -ms-overflow-style: none;
      scroll-snap-type: x mandatory;
      scroll-snap-type: y mandatory;

      /* display: flex;
      transform: translateY(0); */
    }


    html,
    body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      position: fixed;
    }

    .ios-container>.epub-view {
      min-height: 180vh !important;
      margin-top: 40vh !important;
      margin-bottom: 40vh !important;
    }

    /* .ios-container>.epub-view>iframe {
      min-height: 100% !important;
    } */

    #div-loading.show {
      /* background-image: "/images/dplus-logo.png" !important; */
      width: 100vw;
      height: 100vh;
      /* opacity: 0.3; */
      /* background-color: black; */
      display: block !important;
    }

    /* The Modal (background) */
    .searchModal {
      display: none;
      /* Hidden by default */
      position: fixed;
      /* Stay in place */
      z-index: 10;
      /* Sit on top */
      left: 0;
      top: 0;
      width: 100%;
      /* Full width */
      height: 100%;
      /* Full height */
      overflow: auto;
      /* Enable scroll if needed */
      background-color: rgb(0, 0, 0);
      /* Fallback color */
      background-color: rgba(0, 0, 0, 0.4);
      /* Black w/ opacity */

      align-items: center;
      text-align: center;
    }

    .header__inner {
      width: 100vw;
    }

    .epub-view+.epub-view {
      margin-top: 5vh;
    }


    * {
      -webkit-tap-highlight-color: transparent;
    }
        </style>
    </head>
    <body>
        <!-- <select id="toc"></select> -->
        <!-- <div>
    <button onclick="prevChapter();" style="margin-left: 10vw;">이전</button>
    <button onclick="nextChapter();" style="margin-left: 10vw;">다음</button>
    <button onclick="moveToPrevPage();" style="margin-left: 10vw;">되돌</button>
  </div> -->
        <!-- //로딩창 -->
        <div id="div-loading" style="
          position: absolute;
          z-index: 9000;
          display: none;
          left: 0;
          top: 0;
          width: 100vw;
          height: 100vh;
          text-align: center;
          align-items: center;
          " class="Background-1 show">
            <div style="margin: auto;top: 50%;left: 50%;position: absolute;transform: translate(-50%,-50%);">
                <img src="./images/duranno-logo-mobile.png" style="position:relative; display:block; margin:auto; width:min(30vw, 30vh);">
                <span style="position: relative; margin: auto; text-align: center; font-size: min(3vh, 3vw); top : 10px;">
                    정보를 불러오고
        있습니다.
                </span>
            </div>
        </div>
        <div id="image-bookmark" style="position:fixed; top:0em; right:1.3em; z-index:5; height:80px; width:80px; opacity:0; pointer-events: none;">
            <img
                src="images/bookmark_on.png"
                width="25"
                height="25"
                style="float:right"
            ></img>
        </div>
        <div id="viewer"></div>
        <script>
    //#region 온오프라인 체크 
    let connectionChecker = true;
    window.addEventListener("online", connectionStatus);
    window.addEventListener("offline", connectionStatus);
    window.addEventListener("load", connectionStatus);
    function connectionStatus() {
      if (navigator.onLine) {
        connectionChecker = true;
      }
      else {
        connectionChecker = false;
      }
    }

    //#endregion

    //#region adder 영역
    var adder;
    var modifier;
    //endregion

    function iOS() {
      return [
        'iPad Simulator',
        'iPhone Simulator',
        'iPod Simulator',
        'iPad',
        'iPhone',
        'iPod'
      ].includes(navigator.platform)
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
    }

    //#region 멤버, 책 정보 
    let _memberNo = 1;
    let _bookNo = 1;
    let _contentNo = 1;
    let _completeReadYN = "N";
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("memberNo") != null) {
      _memberNo = urlParams.get("memberNo");
    }
    if (urlParams.get("bookNo") != null) {
      _bookNo = urlParams.get("bookNo");
    }
    //#endregion

    const viewer = document.getElementById("viewer");
  
    let iosChecker;

    iosChecker = false; 
    iosChecker = iOS();   //invokeCSharpAction
    let book;
    let rendition;

    //#region getfile
    function getEpub(fileName) {
      return ePub(fileName);
    }

    //#region 초기화
    const adderSize = 180;
    function initRendition(scrolling, spread) {
      var manager = "default";

      if (!iosChecker && scrolling == "scrolled") {
        manager = "continuous";
        viewer.classList.remove("page");
        viewer.classList.add("scroll");
      }
      else if (iosChecker && scrolling == "scrolled") {
        manager = "default";
        viewer.classList.remove("scroll");
        viewer.classList.add("page");
      }
      else {
        viewer.classList.remove("scroll");
        viewer.classList.add("page");
      }
      if (rendition) {
        rendition.destroy();
      }

      rendition = book.renderTo("viewer", {
        manager: manager,
        flow: scrolling,
        spread: spread,
        width: "100vw",
        height: "100vh",
        // height: document.documentElement.clientHeight,
      });


      //adder 초기화 끝
      //클릭 이벤트
      // book.rendition.hooks.content.register(function (contents) {
      //   contents.window.addEventListener("click", function (e) {
      //     let modals = document.getElementsByClassName("modal-highlight");
      //     for (let i = 0; i < modals.length; i++) {
      //       if (!modals[i].style.display == "none") {
      //         e.stopPropagation();
      //       }
      //     }
      //   }, { useCapture: true })
      // });

      //하이포시스에서 보내는 하이라이트 이벤트 등록
      book.rendition.hooks.content.register(function (contents) {
        var annotator = contents.window.annotator;

        contents.window.addEventListener('highlightClick', function (e) {

          var range = e.detail.range;

          var cfi = new ePub.CFI(range, contents.cfiBase).toString();
          if (cfi && e.detail.color) {
            rendition.annotations.highlight(cfi, undefined, undefined, undefined, undefined, e.detail.color);
          }
          var test = new ePub.CFI(cfi);
          e.preventDefault();
        });
      });

      //하이포시스에서 보내는 select 이벤트 등록
      book.rendition.hooks.content.register(function (contents) {
        contents.window.addEventListener('showAdder', function (e) {
          // 김형도 추가
          invokeCSharpAction('{"func": "AdderShown", "params": null}');
        });
      });

      book.rendition.hooks.content.register(function (contents) {
        contents.window.addEventListener('hideAdder', function (e) {
          // 김형도 추가
          invokeCSharpAction('{"func": "AdderHidden", "params": null}');
        });
      });

      rendition.themes.register("./fonts.css");

      rendition.on("attached", function () {
        // if (false) //InvokeCsharpAction
        document.getElementById("div-loading").classList.remove("show");
        // if (false) //InvokeCsharpAction
        scrollingChange("scrolled");


        // registerTouch(true);
        // viewChange("both");
        // rendition.display("epubcfi(/6/6[copyright.xhtml]!/4/70/1:0)");
        // let className = "LineHeight-2 ParagraphHeight-2 ParagraphWidth-1";
        // rendition.themes.font("CustomGungsuh");
        // backgroundChange("Background-5");
        // scrollingChange("scrolled");

        //읽고있던 페이지로 넘어가기 -
        httpGet("GetRecentUseContent", { MemberNo: _memberNo, BookNo: _bookNo }).then((recentUseData) => {
          if (recentUseData && recentUseData.length > 0) {
            _contentNo = recentUseData[0].ContentNo;
            _completeReadYN = recentUseData[0].CompleteReadYN;
            // moveToHRef(recentUseData[0].BookReadingPositionValue);
            // rendition.display();
            // rendition.display(recentUseData[0].BookReadingPositionValue);
            invokeCSharpAction(`{"func": "InitEbookSetting", "params": ${JSON.stringify(recentUseData)}}`);
          }
          else {
            invokeCSharpAction(`{"func": "InitEbookSetting", "params": null}`);
          }
        })

        //북마크 영역
        if (scrolling == "scrolled") {
          if (document.getElementsByClassName("epub-container").length == 0) {
            return;
          }
          var container = document.getElementsByClassName("epub-container")[0];
          //북마크 검사
          container.addEventListener("scroll", () => {
            if (rendition && rendition.location && rendition.location.start) {
              // progress = book.locations.percentageFromCfi(rendition.location.start.cfi);
              var labelBookmark = document.getElementById("image-bookmark");
              for (var i = 0; i < bookmarkList.length; i++) {
                if ((book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 1 ||
                  book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 0) &&
                  (book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.end.cfi) == -1 ||
                    book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.end.cfi) == 0)) {
                  labelBookmark.style.opacity = "1";
                  //0820 여기에서 북마크 표시 - 김형도
                  invokeCSharpAction('{"func": "CheckBookmark", "params": null}');
                  break;
                }
                else {
                  labelBookmark.style.opacity = "0";
                  //0820 여기에서 북마크 없애기 - 김형도
                  invokeCSharpAction('{"func": "UncheckBookmark", "params": null}');
                }
              }
            }
          })
        }
        else if (scrolling == "paginated") {
          rendition.on("relocated", (locations) => {
            if (rendition && rendition.location && rendition.location.start) {
              var labelBookmark = document.getElementById("image-bookmark");
              for (var i = 0; i < bookmarkList.length; i++) {
                if ((book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 1 ||
                  book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 0) &&
                  (book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.end.cfi) == -1)) {
                  labelBookmark.style.opacity = 1;
                  //0820 여기에서 북마크 표시 - 김형도
                  invokeCSharpAction('{"func": "CheckBookmark", "params": null}');
                  break;
                }
                else {
                  labelBookmark.style.opacity = 0;
                  //0820 여기에서 북마크 없애기 - 김형도
                  invokeCSharpAction('{"func": "UncheckBookmark", "params": null}');
                }
              }
            }
          });
        }

        else {
          rendition.on("relocated", (locations) => {
            if (rendition && rendition.location && rendition.location.start) {
              var labelBookmark = document.getElementById("image-bookmark");
              for (var i = 0; i < bookmarkList.length; i++) {
                if ((book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 1 ||
                  book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 0) &&
                  (book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.end.cfi) == -1)) {
                  labelBookmark.style.opacity = 1;
                  //0820 여기에서 북마크 표시 - 김형도
                  invokeCSharpAction('{"func": "CheckBookmark", "params": null}');
                  break;
                }
                else {
                  labelBookmark.style.opacity = 0;
                  //0820 여기에서 북마크 없애기 - 김형도
                  invokeCSharpAction('{"func": "UncheckBookmark", "params": null}');
                }
              }
            }
          });
        }
        // //스타일 등록
        // book.rendition.hooks.content.register(function (contents) {
        //   getBackgroundData(contents.document);
        // })
        // removeSelectArea();

        //스크롤일때 설정 등록 해야함 initrendition 할 때 scroll 일 수 있어서 
        if (iosChecker && scrolling == "scrolled") {
          if (rendition && rendition.flow) {
            rendition.flow(scrolling);
            pageAutoFlipOn();
          }

        }

        //안드로이드 스크롤일때 rendition.next() 한번 호출해주면?? 
        if (!iosChecker && scrolling == "scrolled") {
          rendition.next();
        }
      });

      //0728
      //프로그레스 바 바인딩
      rendition.on("relocated", (locations) => {
        //모든 하이라이트 지우기
        // rendition.annotations.removeAllHighlight();
        let result = changingProgressBar(book.locations.percentageFromCfi(locations.start.cfi));
        closeModal();
        //김형도
        invokeCSharpAction('{"func": "ProgressChanged", "params": [{ "progress": ' + result.progress + ', "chapterName": "' + result.label + '", "currentPage" :' + book.locations.locationFromCfi(locations.start.cfi) + ', cfi: "' + rendition.location.start.cfi + '", "href": "' + rendition.location.start.href + '"}]}');
      });

      //A태그 클릭 이벤트 bubble up 막기 
      book.rendition.hooks.content.register(function (contents) {
        let a = contents.document.getElementsByTagName("a");
        for (let i = 0; i < a.length; i++) {
          a[i].addEventListener("click", function (e) {
            // 이전 페이지 저장
            prevClick = false;
            //
            let hrefStr = e.target.href.replace(document.location.origin, "");

            if (hrefStr.includes("http")) {
              let param = [];
              param.push({ href: e.target.href });
              invokeCSharpAction(`{"func": "OutofBrowser", "params": ${JSON.stringify(param)}}`);
            }
            else if (hrefStr.toLowerCase().includes("mailto:")) {
              let param = [];
              param.push({ href: e.target.innerText });
              invokeCSharpAction(`{"func": "OutofBrowserMail", "params": ${JSON.stringify(param)}}`);
            }

            e.preventDefault();
            e.stopPropagation();
            return false;
          })
        }
      });

      //클릭 막기
      book.rendition.hooks.content.register(function (contents) {
        // 우클릭
        contents.document.addEventListener("contextmenu", function (e) {
          e.preventDefault();
        });
        // 더블클릭
        contents.document.addEventListener("mousedown", (e) => {
          if (e.detail > 1) {
            e.preventDefault();
          }
        }, false);

      });

      // book.rendition.hooks.content.register((contents) => {
      //   contents.document.addEventListener("mouseup", () => {
      //     let selection = contents.document.getSelection();
      //     selection.removeAllRanges();
      //   })
      // })

      //글자수 제한
      book.rendition.hooks.content.register(function (contents) {
        contents.window.addEventListener('copy', function (e) {
          var text = contents.window.getSelection().toString().replace(/[\n\r]+/g, '');
          if (text.length > 50) {
            text = text.substr(0, 50);
          }
          e.clipboardData.setData('text/plain', text);
          e.preventDefault();
        });
      });



      //#region 가로모드 글씨 크기가 커짐 방지
      rendition.hooks.content.register(function (contents) {
        // return contents.addStylesheet(("http://192.168.123.36:8080/web/iphone.css"));
        // 김형도 수정
        return contents.addStylesheet((window.location.origin + window.location.pathname).replace("appindex.html", "") + "iphone.css")
      });



      //#endregion

      //이미지 팝업
      // book.rendition.hooks.content.register(function (contents) {
      //   let imgs = contents.window.document.getElementsByTagName("img");
      //   let eventListener = function (e) {
      //     if (e.type == "touchend" || e.type == "touchmove" || e.type == "mouseup" || e.type == "mousemove") {
      //       window.clearTimeout(pressTimer);
      //     }
      //     else if (e.type == "touchstart" || e.type == "mousedown") {
      //       pressTimer = setTimeout(() => {
      //         let modalImageTag = document.getElementById("modal-content-image");

      //         modalImageTag.src = this.src;
      //         let modal = document.getElementById("modal-image");
      //         modal.style.display = "flex";
      //         changeViewport(true);
      //       }, 500)

      //       if(e.touches && e.touches.length>2){
      //         window.clearTimeout(pressTimer);           
      //       }
      //     }
      //   }
      //   for (let i = 0; i < imgs.length; i++) {
      //     imgs[i].addEventListener("touchend", eventListener.bind(imgs[i]));
      //     imgs[i].addEventListener("touchmove", eventListener.bind(imgs[i]));
      //     imgs[i].addEventListener("mouseup", eventListener.bind(imgs[i]));
      //     imgs[i].addEventListener("mousemove", eventListener.bind(imgs[i]));
      //     imgs[i].addEventListener("touchstart", eventListener.bind(imgs[i]));
      //     imgs[i].addEventListener("mousedown", eventListener.bind(imgs[i]));
      //   }
      // });


      // rendition.on("click", () => {
      //   closeModal();
      // })

      //#region 하이라이트 할수있는 UI 
      rendition.on("customSelect", (range, contents, startTop, startLeft, endTop, endLeft, text, doc) => {

        if (iosChecker) {
          // let left;
          // let top;

          if (connectionChecker == false) {
            return;
          }
          if (iosChecker == true && viewer.classList.contains("scroll")) {

            let scrollTop = document.getElementsByClassName("epub-container")[0].scrollTop;
            let marginTop = (document.documentElement.clientHeight * 4 / 10);
            let realMove = scrollTop - marginTop;
            if (endTop - realMove < (document.documentElement.clientHeight / 2)) {
              // adder.show(endLeft, endTop - realMove, range, text);
            }
            else if (endTop - realMove > (document.documentElement.clientHeight / 2)) {
              // adder.show(endTop, startTop - realMove - adderSize, range, text);
            }

            startTop = startTop - realMove;
            endTop = endTop - realMove;
          }
          if (viewer.classList.contains("page")) {

            // let left = x - document.getElementsByClassName("epub-container")[0].scrollLeft;
            // let top = y - document.getElementsByClassName("epub-container")[0].scrollTop;

            // if (endTop > (document.documentElement.clientHeight / 2)) {
            startLeft = startLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
            startTop = startTop - document.getElementsByClassName("epub-container")[0].scrollTop;

            endLeft = endLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
            endTop = endTop - document.getElementsByClassName("epub-container")[0].scrollTop;
            // adder.show(left, top, range, text);
            // }
            //
            // else if (endTop < (document.documentElement.clientHeight / 2)) {

            //   left = endLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
            //   top = endTop - document.getElementsByClassName("epub-container")[0].scrollTop;

            //   // adder.show(left + 10, top + 10, range, text);
            // }
            // adder.show(left + 10, top + 10, range, text);
          }
          else if (viewer.classList.contains("scroll")) {
            let left;
            let top;
            let views = document.getElementsByClassName("epub-view");
            let docs = rendition.getAllContents();
            for (let i = 0; i < docs.length; i++) {
              if (docs[i].contents == doc) {
                let scrollHeight = document.getElementsByClassName("epub-container")[0].scrollTop;
                let containerHeight = document.getElementsByClassName("epub-container")[0].clientHeight;
                if (i == 0) {
                  // if (endTop - scrollHeight > (document.documentElement.clientHeight / 2)) {
                  //   left = startLeft;
                  //   top = startTop;
                  // }
                  // else if (endTop - scrollHeight < (document.documentElement.clientHeight / 2)) {
                  //   left = endLeft;
                  //   top = endTop;
                  // }
                  startTop = startTop - scrollHeight;
                }
                else if (i > 0) {
                  let height = 0;
                  for (let j = 0; j < i; j++) {
                    height += views[j].clientHeight;
                  }
                  height += document.documentElement.offsetHeight * 5 / 100 * i;
                  // if (endTop + height - scrollHeight > (document.documentElement.clientHeight / 2)) {
                  //   left = startLeft;
                  //   top = startTop - adderSize;
                  // }
                  // else if (endTop + height - scrollHeight < (document.documentElement.clientHeight / 2)) {
                  //   left = endLeft;
                  //   top = endTop;
                  // }

                  startTop = startTop + height - scrollHeight;
                  endTop = endTop + height - scrollHeight;
                }
              }
            }

            // if (endTop + height - scrollHeight > (document.documentElement.clientHeight / 2)) {
            //   // adder.show(left - 10, top - 10, range, text);
            // }
            // else if (endTop + height - scrollHeight < (document.documentElement.clientHeight / 2)) {
            //   // adder.show(left + 10, top + 10, range, text);
            // }

          }
          let appParam = {};
          appParam.cfi = range;
          appParam.startTop = startTop;
          appParam.startLeft = startLeft;
          appParam.endTop = endTop;
          appParam.endLeft = endLeft;
          appParam.selectedText = text;
          let paramList = [];
          paramList.push(appParam);
          adder.cfi = range;
          invokeCSharpAction(`{"func": "SelectEnd", "params": ${JSON.stringify(paramList)}}`);
        }
        else {
          if (connectionChecker == false) {
            return;
          }
          // if (iosChecker == true && viewer.classList.contains("scroll")) {

          //   let scrollTop = document.getElementsByClassName("epub-container")[0].scrollTop;
          //   let marginTop = (document.documentElement.clientHeight * 4 / 10);
          //   let realMove = scrollTop - marginTop;
          //   if (endTop - realMove < (document.documentElement.clientHeight / 2)) {
          //     adder.show(endLeft, endTop - realMove, range, text);
          //   }
          //   else if (endTop - realMove > (document.documentElement.clientHeight / 2)) {
          //     adder.show(endTop, startTop - realMove - adderSize, range, text);
          //   }
          //   return;
          // }
          // if (viewer.classList.contains("page")) {

          //   // let left = x - document.getElementsByClassName("epub-container")[0].scrollLeft;
          //   // let top = y - document.getElementsByClassName("epub-container")[0].scrollTop;
          //   let left;
          //   let top;
          //   if (endTop > (document.documentElement.clientHeight / 2)) {
          //     left = startLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
          //     top = startTop - document.getElementsByClassName("epub-container")[0].scrollTop - adderSize;

          //     adder.show(left, top, range, text);
          //   }
          //   else if (endTop < (document.documentElement.clientHeight / 2)) {
          //     left = endLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
          //     top = endTop - document.getElementsByClassName("epub-container")[0].scrollTop;

          //     adder.show(left + 10, top + 10, range, text);
          //   }
          //   // adder.show(left + 10, top + 10, range, text);
          // }
          // else if (viewer.classList.contains("scroll")) {
          //   let left;
          //   let top;
          //   let height = 0;
          //   let scrollHeight = document.getElementsByClassName("epub-container")[0].scrollTop;
          //   let containerHeight = document.getElementsByClassName("epub-container")[0].clientHeight;
          //   let views = document.getElementsByClassName("epub-view");
          //   let docs = rendition.getAllContents();
          //   for (let i = 0; i < docs.length; i++) {
          //     if (docs[i].contents == doc) {

          //       if (i == 0) {
          //         if (endTop - scrollHeight > (document.documentElement.clientHeight / 2)) {
          //           left = startLeft;
          //           top = startTop;
          //         }
          //         else if (endTop - scrollHeight < (document.documentElement.clientHeight / 2)) {
          //           left = endLeft;
          //           top = endTop;
          //         }
          //         top = top - scrollHeight;
          //       }
          //       else if (i > 0) {

          //         for (let j = 0; j < i; j++) {
          //           height += views[j].clientHeight;
          //         }
          //         height += document.documentElement.offsetHeight * 5 / 100 * i;
          //         if (endTop + height - scrollHeight > (document.documentElement.clientHeight / 2)) {
          //           left = startLeft;
          //           top = startTop - adderSize;
          //         }
          //         else if (endTop + height - scrollHeight < (document.documentElement.clientHeight / 2)) {
          //           left = endLeft;
          //           top = endTop;
          //         }
          //         top = top + height - scrollHeight;
          //       }
          //     }
          //   }

          //   if (endTop + height - scrollHeight > (document.documentElement.clientHeight / 2)) {
          //     adder.show(left - 10, top - 10, range, text);
          //   }
          //   else if (endTop + height - scrollHeight < (document.documentElement.clientHeight / 2)) {
          //     adder.show(left + 10, top + 10, range, text);
          //   }

          // }

          if (viewer.classList.contains("page")) {
            // let left = x - document.getElementsByClassName("epub-container")[0].scrollLeft;
            // let top = y - document.getElementsByClassName("epub-container")[0].scrollTop;
            let left;
            let top;
            // if (startTop > document.documentElement.clientHeight / 2) {
            //   left = startLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
            //   top = startTop - document.getElementsByClassName("epub-container")[0].scrollTop - adderSize;
            // } 
            // else if (startTop < document.documentElement.clientHeight / 2) {
            left = endLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
            top = endTop - document.getElementsByClassName("epub-container")[0].scrollTop;
            // }
            if (document.documentElement.clientWidth < left) {
              left = startLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
              top = startTop - document.getElementsByClassName("epub-container")[0].scrollTop;
            }
            if (left < 0) {
              left = (document.documentElement.clientWidth / 2);
            }
            if (adderReady)
              adder.show(left, top, range, text);
          }
          else if (viewer.classList.contains("scroll")) {
            let left;
            let top;
            let views = document.getElementsByClassName("epub-view");
            let docs = rendition.getAllContents();
            for (let i = 0; i < docs.length; i++) {
              if (docs[i].contents == doc) {
                let scrollHeight = document.getElementsByClassName("epub-container")[0].scrollTop;
                let containerHeight = document.getElementsByClassName("epub-container")[0].clientHeight;
                if (i == 0) {
                  // if (startTop - scrollHeight > document.documentElement.clientHeight / 2) {
                  //   left = startLeft;
                  //   top = startTop;
                  // }
                  // else if (startTop - scrollHeight < document.documentElement.clientHeight / 2) {
                  left = endLeft;
                  top = endTop;
                  // }
                  top = top - scrollHeight;
                }
                else if (i > 0) {
                  let height = 0;
                  for (let j = 0; j < i; j++) {
                    height += views[j].offsetHeight;
                  }
                  height += document.documentElement.offsetHeight * 5 / 100 * i;
                  // if (startTop + height - scrollHeight > document.documentElement.clientHeight / 2) {
                  //   left = startLeft;
                  //   top = startTop - adderSize;
                  // }
                  // else if (startTop + height - scrollHeight < document.documentElement.clientHeight / 2) {
                  left = endLeft;
                  top = endTop;
                  // }
                  top = top + height - scrollHeight;
                }
              }
            }
            if (adderReady)
              adder.show(left, top, range, text);
          }
        }
      })
      //#endregion

      //#region DB 하이라이트 가져오기
      if (connectionChecker == true) {
        httpGet("getnote", { MemberNo: _memberNo, BookNo: _bookNo }).then((data) => {
          for (let i = 0; i < data.length; i++) {
            if (rendition.epubcfi.checkType(data[i].NotePositionValue)) {
              if (data[i].NoteHighlightColorKindcode.length > 0) {
                httpGet("getValueByCode", { Code: data[i].NoteHighlightColorKindcode, GroupCode: "V01" }).then(function (value) {
                  value = value[0].backgroundColor;
                  if (data[i].NoteText.length > 0) {
                    rendition.annotations.add("highlight", data[i].NotePositionValue, { memo: true }, undefined, undefined, undefined, value)
                  }
                  else {
                    rendition.annotations.add("highlight", data[i].NotePositionValue, undefined, undefined, undefined, undefined, value)
                  }
                })
              }
            }
          }
        })

      }


      //#region 마크 클릭 이벤트 
      rendition.on("markClicked", function (cfi, data, content, range) {
        let loc = content.selectionObserver.getLoc(rendition.getRange(cfi));
        httpGet("GetNoteByPosition", { MemberNo: _memberNo, BookNo: _bookNo, NotePositionValue: cfi }).then((result) => {
          window.setTimeout(() => {
            let startTop;
            let endTop;
            let startLeft;
            let endLeft;
            let top;
            let left;
            startTop = loc.startTop;
            endTop = loc.endTop;
            startLeft = loc.startLeft;
            endLeft = loc.endLeft;
            if (iosChecker == true && viewer.classList.contains("scroll")) {
              left = endLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
              top = endTop - document.getElementsByClassName("epub-container")[0].scrollTop;
              if (document.documentElement.clientWidth < left) {
                left = startLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
                top = startTop - document.getElementsByClassName("epub-container")[0].scrollTop;
              }
              if (document.documentElement.clienWidth > left) {
                left = (document.documentElement.clientWidth - adderSize)
              }
              if (left < 0) {
                left = (document.documentElement.clientWidth / 2);

              }
              modifier.show(left, top, cfi, result[0].NoteTableContent);
              invokeCSharpAction(`{"func": "SelectStart", "params": null}`);
              return;
            }
            if (viewer.classList.contains("page")) {

              let left;
              let top;
              left = endLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
              top = endTop - document.getElementsByClassName("epub-container")[0].scrollTop;
              if (document.documentElement.clientWidth < left) {
                left = startLeft - document.getElementsByClassName("epub-container")[0].scrollLeft;
                top = startTop - document.getElementsByClassName("epub-container")[0].scrollTop;
              }
              if (document.documentElement.clienWidth > left) {
                left = (document.documentElement.clientWidth - adderSize)
              }
              if (left < 0) {
                left = (document.documentElement.clientWidth / 2);
              }
              modifier.show(left, top, cfi, result[0].NoteTableContent);
              invokeCSharpAction(`{"func": "SelectStart", "params": null}`);
            }
            else if (viewer.classList.contains("scroll")) {
              let left;
              let top;
              let views = document.getElementsByClassName("epub-view");
              let docs = rendition.getAllContents();
              for (let i = 0; i < docs.length; i++) {
                if (docs[i].contents == content) {
                  let scrollHeight = document.getElementsByClassName("epub-container")[0].scrollTop;
                  if (i == 0) {
                    if (startTop - scrollHeight > (document.documentElement.clientHeight / 2)) {
                      left = startLeft;
                      top = startTop - adderSize;
                    }
                    else if (startTop - scrollHeight < (document.documentElement.clientHeight / 2)) {
                      left = endLeft;
                      top = endTop;
                    }
                    top = top - scrollHeight;
                  }
                  else if (i > 0) {
                    let height = 0;
                    for (let j = 1; j < i; j++) {
                      height += views[j].clientHeight;
                    }
                    if (startTop + height + views[0].clientHeight - scrollHeight > (document.documentElement.clientHeight / 2)) {
                      left = startLeft;
                      top = startTop - adderSize;
                    }
                    else if (startTop + height + views[0].clientHeight - scrollHeight < (document.documentElement.clientHeight / 2)) {
                      left = endLeft;
                      top = endTop;
                    }
                    top = top + height + views[0].clientHeight - scrollHeight;
                  }
                }
              }
              modifier.show(left, top, cfi, result[0].NoteTableContent);
              invokeCSharpAction(`{"func": "SelectStart", "params": null}`);
            }
          }, 100);
        })
      })
      //#endregion

      rendition.on("customSelectCancel", function () {
        if (iosChecker) {
          invokeCSharpAction(`{"func": "SelectStart", "params": null}`);
          window.setTimeout(function () {
            if (adder) {
              adder.hide();
            }
            if (modifier) {
              modifier.hide();
            }
          }, 200)
        }
        else {
          window.setTimeout(function () {
            if (adder) {
              adder.hide();
            }
            if (modifier) {
              modifier.hide();
            }
          }, 200)
        }
      })

      //#region 북마크 가져오기
      if (connectionChecker == true) {
        httpGet("getbookmark", { BookNo: _bookNo, MemberNo: _memberNo }).then(function (data) {
          for (let i = 0; i < data.length; i++) {
            if (rendition.epubcfi.checkType(data[i].BookMarkPositionValue)) {
              var bookmarkItem = {};
              bookmarkItem.cfi = data[i].BookMarkPositionValue;
              bookmarkItem.progress = data[i].BookMarkPercentage;
              bookmarkItem.bookmarkString = data[i].BookMarkTableContent;
              bookmarkList.push(bookmarkItem);
            }
          }
        })
      }

      rendition.on("rendered", function () {
        if (!iosChecker) {
          changeViewport(true);
        }
        window.setTimeout(function () {
          invokeCSharpAction('{"func": "RenderComplete", "params": null}');
        }, 100)

        if (!viewer.classList.contains("page")) {
          return;
        }
        if (rendition && rendition.currentLocation && rendition.currentLocation().start) {
          if (rendition.currentLocation().start.index == 0 && iosChecker == false) {
            if (document.getElementById("viewer").getElementsByTagName("iframe").length > 0 && document.getElementById("viewer").getElementsByTagName("iframe")[0].contentDocument.getElementsByTagName("img").length > 0) {
              let img = document.getElementById("viewer").getElementsByTagName("iframe")[0].contentDocument.getElementsByTagName("img")[0];
              img.style.position = "absolute";
              img.style.top = "50%";
              img.style.left = "50%";
              img.style.transform = "translate(-50%,-50%)";
            }
          }
        }
        prevClick = false;
      })


      if (false)  //invokeCSharpAction
      rendition.display();



      rendition.on("attached", () => {
      })

      // rendition.on("displayed", function(){
      //   if(iosChecker && viewer.classList.contains("scroll")){
      //     let parent = document.getElementsByClassName("epub-view")[0]?.parentElement;
      //     let topImg = `<img src="./images/duranno-logo-mobile.png" style="top:0; left:50%; transform: translate(0,20vh); position:absolute; height:10vh;"></img>`;
      //     let bottomImage = `<img src="./images/duranno-logo-mobile.png" style="left:50%; transform: translate(0,-20vh); position:absolute; height:10vh;"></img>`;

      //     const template = document.createElement("template");
      //     template.innerHTML = topImg;

      //     parent.appendChild(template.content.cloneNode(true));
      //     template.innerHTML = bottomImage;
      //     parent.appendChild(template.content.cloneNode(true));
      //   }
      
      // })
    }
    //initRendition 끝 =====================================


    function bookChange(fileName, scrolling, spread) {
      // console.log(APP_EVENT.SCROLL.SCROLLED);
      if (book) {
        book.destroy();
        book = null;
        rendition.destroy();
        rendition = null;
      }
      book = getEpub(fileName);
      if (false)  ////invokeCSharpAction (주석 편하게 하려고 넣은거)
      initRendition(scrolling, spread);
    }
    //#endregion


    // let ttt = true;
    window.addEventListener("resize", function () {

      if (iosChecker) {
        //페이지 자동넘김시 resize 되어서 relocated 되는건지 페이지가 넘어가는건지 구분하기위해
        const container = document.getElementsByClassName("epub-container")[0];
        if (container) container.resizeStart = true;
        //viewport change
        changeViewport(false);
        changeViewport(true);
      }
      else {
        changeViewport(false);
      }

      // if (ttt) {
      //   viewChange("both");
      //   ttt = false;
      // }
      // else {
      //   viewChange("none");
      //   ttt = true;
      // }
    });

    //#region 파라미터가져오기    
    function getParam(sname) {
      var params = location.search.substr(location.search.indexOf("?") + 1);
      var sval = "";
      params = params.split("&");
      for (var i = 0; i < params.length; i++) {
        temp = params[i].split("=");
        if ([temp[0]] == sname) { sval = temp[1]; }
      }
      return sval;
    }
    //#endregion

    //#region ebook init
    var ePubFileName;
    window.onload = () => {
      bookChange(getParam("epub"), "scrolled", "none");
      ePubFileName = getParam("epub");

      //#region page 체크
      book.ready.then(function () {
        // const stored = localStorage.getItem(book.key() + '-locations');
        // // console.log('metadata:', book.package.metadata);
        // if (stored) {
        //   return book.locations.load(stored);
        // } else {
        //   return book.locations.generate(1000); // Generates CFI for every X characters (Characters per/page)
        // }
        return book.locations.generate(1000);
      }).then(function (location) { // This promise will take a little while to return (About 20 seconds or so for Moby Dick)
        adderReady = true;
        // localStorage.setItem(book.key() + '-locations', book.locations.save());               
        getCurrentChapter().then(function (data) {
          let param = data.chapterInfo;
          let cfi = param.cfi;
          param.currentCfi = param.cfi;
          param.currentChapterHref = param.href;
          param.progress = param.progress;
          param.page = param.page;
          if (rendition.location && book.locations) {
            cfi = rendition.location.start.cfi;
            param.currentCfi = cfi;
            param.currentChapterHref = param.href;
            param.progress = book.locations.percentageFromCfi(cfi);
            param.page = book.locations.locationFromCfi(cfi);
          }
          param.total = book.locations.total;
          //김형도
          invokeCSharpAction('{"func": "SetProgressTotal", "params": [' + JSON.stringify(param) + ']}');

          //북마크 버튼 활성화 
          document.getElementById("image-bookmark").style.pointerEvents = "auto";
        })

        //현재위치 저장 처음 한번 호출해야해서 
        let param = {};
        param.MemberNo = _memberNo;
        param.ContentNo = _bookNo;
        param.BookReadingPositionValue = "";
        param.BookReadingProgressRate = 0;
        if (rendition && rendition.location) {
          param.BookReadingPositionValue = rendition.location.start.cfi;
          param.BookReadingProgressRate = Math.ceil((book.locations.percentageFromCfi(rendition.location.start.cfi) * 100));
        }
        httpPost("ManageRecentUseContentData", param).then(function (result) {

        })
        rendition.on("locationChanged", (e) => {
          let param = {};
          param.MemberNo = _memberNo;
          param.ContentNo = _bookNo;
          param.BookReadingPositionValue = e.start;
          param.BookReadingProgressRate = Math.ceil((book.locations.percentageFromCfi(e.start) * 100));
          httpPost("ManageRecentUseContentData", param).then(function (result) {
          })
        });

      });

      //#endregion
    }

    //#endregion


    //페이지 바 초기화
    // Generate location and pagination
    let adderReady = false;


    //#region 텍스트검색
    async function findText(text) {
      if (text.length < 1) return;
      var foundText = [];
      var promises = [];
      rendition.book.spine.spineItems.forEach((spineItem) => {
        var promise = spineItem.load.call(spineItem, rendition.book.load.bind(rendition.book));
        promises.push(promise);
      })
      await Promise.all(promises);
      rendition.book.spine.spineItems.forEach((spineItem) => {
        var findResult = spineItem.find(text);
        findResult.forEach((fr) => {
          var foundItem = {};
          foundItem.text = fr.excerpt;
          foundItem.cfi = fr.cfi;
          foundItem.chapter = chapterFromCfi(fr.cfi);
          foundItem.percentage = book.locations.percentageFromCfi(fr.cfi);
          foundText.push(foundItem);
        })
      })
      return foundText;
    }

    async function chapterFromCfi(cfi) {
      let chapter = {};
      let spineItem = book.spine.get(cfi);
      let navItem = book.navigation.get(spineItem.href);
      if (navItem) {
        chapter.chapter = navItem.label;
      }

      if (navItem && navItem.parent == undefined) {
        chapter.chapterParent = navItem.label;
      } else {
        while (spineItem.prev()) {
          spineItem = spineItem.prev();
          navItem = book.navigation.get(spineItem.href);
          if (navItem) {
            if (!(chapter.chapter)) chapter.chapter = navItem.label;
          }
          if (navItem && navItem.parent == undefined) {
            if (!(chapter.chapter)) chapter.chapter = navItem.label;
            chapter.chapterParent = navItem.label;
            break;
          }
        }
      }
      chapter.chapter = chapter.chapter.replace(/(\r\n|\n|\r)/gm, "");
      chapter.chapterParent = chapter.chapterParent.replace(/(\r\n|\n|\r)/gm, "");
      chapter.chapter = chapter.chapter.replace(/^\s+/, "");
      chapter.chapter = chapter.chapter.replace(/\s+$/, "");
      chapter.chapterParent = chapter.chapterParent.replace(/^\s+/, "");
      chapter.chapterParent = chapter.chapterParent.replace(/\s+$/, "");
      return chapter;
    }
    function findTextJsonString(text) {
      var t = findText(text);
      t.then(function (foundText) {
        let promises = [];
        for (let item of foundText) {
          promises.push(item.chapter)
        }
        if (promises.length == 0) {
          invokeCSharpAction(`{"func": "FindTextResponse", "params": null}`);
          return;
        }
        let count = 0;
        for (let promise of promises) {
          promise.then(function (data) {
            foundText[count].chapter = data.chapter;
            count++;
            if (count == foundText.length) {
              // 김형도 수정
              invokeCSharpAction(`{"func": "FindTextResponse", "params": ${JSON.stringify(foundText)}}`);
            }
          })
        }
      });
    }
    //#endregion

    //#region app function
    const APP_EVENT = {
      SWIPE: {
        LEFT: "left",
        RIGHT: "right",
      },
      BACKGROUND_COLOR: {
        BACKGROUND1: "Background-1",
        BACKGROUND2: "Background-2",
        BACKGROUND3: "Background-3",
        BACKGROUND4: "Background-4",
        BACKGROUND5: "Background-5",
        BACKGROUND6: "Background-6",
        BACKGROUND7: "Background-7",
      },
      FONT: {
        // GUNGSUH: "CustomGungsuh",
        BATANG: "CustomBatang",
        BATANG_M: "CustomBatangMedium",
        NANUMMYEONGJO: "NanumMyeongjo",
        MALGUNGOTHIC: "MalgunGothic",
        BONGOTHIC: "BonGothic",
        Dotum: "Dotum",
      },
      VIEW_FORMAT: {
        ONESIDEVIEW: "none",
        TWOSIDEVIEW: "both",
      },
      SCROLL: {
        PAGINATED: "paginated",
        SCROLLED: "scrolled",
      },
      LINE_HEIGHT: {
        ONE: "LineHeight-1",
        TWO: "LineHeight-2",
        THREE: "LineHeight-3",
        FOUR: "LineHeight-4",
        FIVE: "LineHeight-5",
        SIX: "LineHeight-6",
      },
      ALIGN: {
        LEFT: "AlignLeft",
        CENTER: "AlignCenter",
        RIGHT: "AlignRight",
        JUSTIFY: "AlignJustify",
      },
      PARAGRAPH_HEIGHT: {
        ONE: "ParagraphHeight-1",
        TWO: "ParagraphHeight-2",
        THREE: "ParagraphHeight-3",
        FOUR: "ParagraphHeight-4",
        FIVE: "ParagraphHeight-5",
        SIX: "ParagraphHeight-6",
      },
      PARAGRAPH_WIDTH: {
        ONE: "ParagraphWidth-1",
        TWO: "ParagraphWidth-2",
        THREE: "ParagraphWidth-3",
        FOUR: "ParagraphWidth-4",
        FIVE: "ParagraphWidth-5",
        SIX: "ParagraphWidth-6",
      }
    }
    //하이라이트 다시 그리기
    function highlightRedraw() {
      if (rendition && rendition.manager && rendition.manager.views && rendition.manager.views._views && rendition.manager.views._views.length > 0) {
        for (let i = 0; i < rendition.manager.views._views.length; i++) {
          rendition.manager.views._views[i].removeHighlight();
          rendition.hooks.show.trigger(rendition.manager.views._views[i], rendition);
        }
      }
    }
    //parameter White, Dark
    function backgroundChange(theme) {
      var className = rendition.themes._current;
      var classes = className.split(" ");
      if (classes.length > 0) {
        className = "";
        classes.forEach(element => {
          if (element.indexOf("Background") == -1)
            className += element + " ";
        }
        );
      }
      className += theme;
      rendition.themes.select(className);
      let viewerClasses = viewer.className.split(' ');

      for (let i = 0; i < viewerClasses.length; i++) {
        if (viewerClasses[i].indexOf("Background") >= 0) {
          viewerClasses.splice(i, 1);
        }
      }
      if (theme) {
        viewerClasses.push(theme);
      }
      viewer.classList = "";
      for (let i = 0; i < viewerClasses.length; i++) {
        viewer.classList.add(viewerClasses[i]);
      }

      document.getElementById("div-loading").className = "";
      if (theme) {
        document.getElementById("div-loading").classList.add(theme);
      }
      else {
        document.getElementById("div-loading").classList.add("Background-1");
      }
    }

    function fixSize() {
      if (rendition && rendition.resize) {
        rendition.resize("100vw", "100vh");
      }

    }

    //parameter  none, both;
    function viewChange(view) {
      if (rendition && rendition.spread) {
        rendition.spread(view);
      }


      window.setTimeout(function () {
        highlightRedraw();
      }, 500);
    }

    function updateLayout() {
      rendition.resize("100vw", "99vh");
      rendition.resize("100vw", "100vh");
    }
    //paramter Gungsuh, Batang
    function fontSizeChange(fontSize) {
      let storedLocation = "";
      if (rendition && rendition.location) {
        storedLocation = rendition.location.start.cfi;
      }

      if (fontSize) {
        rendition.themes.fontSize(fontSize);
      }
      else {
        rendition.themes.fontSize("");
      }


      if (storedLocation) {
        rendition.display(storedLocation).then(function () {
          highlightRedraw();
        });
      }
    }
    //parameter number(%)
    function fontChange(font) {
      rendition.themes.font(font);
      highlightRedraw();
    }

    //parameter : paginated, scrolled
    function scrollingChange(scrolling) {
      let currentStartCfi;
      if (scrolling == "scrolled") {
        viewer.classList.remove("page");
        viewer.classList.add("scroll");
        if (scrolling == "scrolled" &&
          rendition && rendition.ViewManager && rendition.ViewManager.name && rendition.ViewManager.name.includes
          && rendition.ViewManager.name.includes("DefaultViewManager") && iosChecker == false) {
          if (rendition.currentLocation().start != null) {
            currentStartCfi = rendition.currentLocation().start.cfi;
          }

          initRendition("scrolled", rendition._layout._spread ? "both" : "none");
          window.setTimeout(() => {
            rendition.display(currentStartCfi);
          }, 300);

        }
        else {
          if (rendition && rendition.flow) {
            rendition.flow(scrolling);
          }

          if (iosChecker) {
            pageAutoFlipOn();
          }
        }
      }
      else if (scrolling == "paginated") {
        viewer.classList.add("page");
        viewer.classList.remove("scroll");
        if (scrolling == "paginated" && rendition.ViewManager && rendition.ViewManager.name && rendition.ViewManager.name.includes
          && rendition.ViewManager.name.includes("ContinuousViewManager") && iosChecker == false) {
          if (rendition.currentLocation().start != null) {
            currentStartCfi = rendition.currentLocation().start.cfi;
          }
          initRendition("paginated", rendition._layout._spread ? "both" : "none");

          window.setTimeout(() => {
            rendition.display(currentStartCfi);
          }, 300);
        }
        else {
           if (iosChecker) {
            removeTopBottomArrow();
            pageAutoFlipOff();
          }
          rendition.flow(scrolling);
         
        }
      }
      highlightRedraw();
    }

    function swipeLeft() {

      if (Math.abs(window.innerWidth - document.documentElement.clientWidth) < 10) {
        //연속 이동 때문에 넣음 ios
        relocateAllow = false;
        setTimeout(function () {
          relocateAllow = true;
        }, 300)

        prevClick = true;
        rendition.prev();
        invokeCSharpAction(`{"func": "SelectStart", "params": null}`);

        const view = document.getElementsByClassName("epub-view");
        if (view && view.length > 0) {
          const iframe = view[0].getElementsByTagName("iframe");
          if (iframe && iframe.length > 0) {
            iframe[0].contentWindow.document.getSelection().removeAllRanges();
          }
        }
      }
      closeModal();
    }

    function swipeRight() {


      if (Math.abs(window.innerWidth - document.documentElement.clientWidth) < 10) {
        //연속 이동 때문에 넣음 ios
        relocateAllow = false;
        setTimeout(function () {
          relocateAllow = true;
        }, 300)

        //select 끄고 
        prevClick = true;
        rendition.next();
        invokeCSharpAction(`{"func": "SelectStart", "params": null}`);

        const view = document.getElementsByClassName("epub-view");
        if (view && view.length > 0) {
          const iframe = view[0].getElementsByTagName("iframe");
          if (iframe && iframe.length > 0) {
            iframe[0].contentWindow.document.getSelection().removeAllRanges();
          }
        }
      }
      // if (document.documentElement.scrollWidth <= window.innerWidth + document.documentElement.scrollLeft) {
      //   prevClick = true;
      //   rendition.next();
      // }
      closeModal();
    }

    //줄간격
    function lineHeightChange(lineHeight) {
      var className = rendition.themes._current;
      var classes = className.split(" ");
      if (classes.length > 0) {
        className = "";
        classes.forEach(element => {
          if (element.indexOf("LineHeight") == -1)
            className += element + " ";
        }
        );
      }
      className += lineHeight;
      rendition.themes.select(className);
      highlightRedraw();
    }

    //정렬
    function alignChange(align) {
      var className = rendition.themes._current;
      var classes = className.split(" ");
      if (classes.length > 0) {
        className = "";
        classes.forEach(element => {

          if (element.indexOf("Align") == -1)
            className += element + " ";
        }
        );
      }
      className += align;
      rendition.themes.select(className);
      highlightRedraw();
    }

    //문단간격
    function paragraphHeightChange(height) {
      var className = rendition.themes._current;
      var classes = className.split(" ");
      if (classes.length > 0) {
        className = "";
        classes.forEach(element => {

          if (element.indexOf("ParagraphHeight") == -1)
            className += element + " ";
        }
        );
      }
      className += height;
      rendition.themes.select(className);
      highlightRedraw();
    }
    //문단 너비 ( ex ) 100% ) 
    function paragraphWidthChange(width) {
      var className = rendition.themes._current;
      var classes = className.split(" ");
      if (classes.length > 0) {
        className = "";
        classes.forEach(element => {
          if (element.indexOf("ParagraphWidth") == -1)
            className += element + " ";
        }
        );
      }
      className += width;
      rendition.themes.select(className);
      highlightRedraw();
    }

    // 페이지 이동 
    function moveToPage(page) {
      prevClick = false;
      rendition.display(book.locations._locations[page]);
    }
    function moveToPrevPage() {
      if (prevPage.length > 0) {
        prevClick = true;
        rendition.display(prevPage.pop());
      }

    }

    //북마크 
    var bookmarkList = [];
    function getBookmark() {
      return bookmarkList;
    }
    document.getElementById("image-bookmark").addEventListener("click", async function () {
      var bookmarkProgress = book.locations.percentageFromCfi(rendition.currentLocation().start.cfi);
      let bookmarkLocation = book.locations.locationFromCfi(rendition.currentLocation().start.cfi);
      //북마크가 있는지 검사
      if (this.style.opacity > 0) {
        for (var i = 0; i < bookmarkList.length; i++) {

          if ((book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 1 ||
            book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.start.cfi) == 0) &&
            (book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.end.cfi) == -1 ||
              book.locations.epubcfi.compare(bookmarkList[i].cfi, rendition.location.end.cfi) == 0)) {
            // this.style.display = "none";
            this.style.opacity = 0;
            httpPost("removebookmark", { MemberNo: _memberNo, BookNo: _bookNo, BookMarkPositionValue: bookmarkList[i].cfi });
            bookmarkList.splice(i, 1);
            //0820 여기에서 북마크 없애기 - 김형도
            invokeCSharpAction('{"func": "UncheckBookmark", "params": null}');

                return;
          }
        }
      }

      else {
        addBookmark();
        invokeCSharpAction('{"func": "CheckBookmark", "params": null}');
      }
    });

    function addBookmark() {
      var bookmarkProgress = book.locations.percentageFromCfi(rendition.currentLocation().start.cfi);
      var bookmarkString = location.host + location.pathname + "?epub=" + ePubFileName + "&goto=" + rendition.location.start.cfi;
      let imageBookmark = document.getElementById("image-bookmark");
      imageBookmark.style.opacity = 1;
      var bookmarkItem = {};
      bookmarkItem.cfi = rendition.location.start.cfi;
      bookmarkItem.progress = bookmarkProgress;
      bookmarkItem.bookmarkString = bookmarkString;
      bookmarkList.push(bookmarkItem);
      chapterFromCfi(bookmarkItem.cfi).then((chapter) => {
        chapter.chapter = chapter.chapter.replace(/(\r\n|\n|\r)/gm, "");
        chapter.chapterParent = chapter.chapterParent.replace(/(\r\n|\n|\r)/gm, "");
        chapter.chapter = chapter.chapter.replace(/^\s+/, "");
        chapter.chapter = chapter.chapter.replace(/\s+$/, "");
        chapter.chapterParent = chapter.chapterParent.replace(/^\s+/, "");
        chapter.chapterParent = chapter.chapterParent.replace(/\s+$/, "");
        httpPost("addbookmark", {
          MemberNo: _memberNo, BookNo: _bookNo, BookMarkPositionValue: bookmarkItem.cfi, BookMarkTableContent: chapter.chapter, BookMarkTableContentSub: chapter.chapterParent, BookMarkPage: 1, BookMarkPercentage: Math.round(bookmarkItem.progress * 100),
        }).then(function (result) {
          if (result < 1) {
            alert("북마크 등록 실패 관리자에게 문의바랍니다.");
          }
        })

      });
      //0820 여기에서 북마크 표시
    }

    //0820 앱에서 북마크 삭제 할때 부르는 함수
    function removeBookmark() {
      document.getElementById("image-bookmark").click();
    }

    function removeBookmarkInNote(loc) {
      httpPost("removebookmark", {
        MemberNo: _memberNo,
        BookNo: _bookNo,
        BookMarkPositionValue: loc,
      }).then(function (result) {
        if (result < 1) {
          alert("북마크 삭제 실패 관리자에게 문의바랍니다.");
        } else {
          removeBookmarkByCfi(loc);
        }
      })
    }

    function removeBookmarkByCfi(cfi) {
      for (let i = 0; i < bookmarkList.length; i++) {
        if (bookmarkList[i].cfi == cfi) {
          bookmarkList.splice(i, 1);
        }
      }
      if (checkBookmarkThisPage(cfi)) {
        invokeCSharpAction('{"func": "UncheckBookmark", "params": null}');
        // document.getElementById("image-bookmark").style.display = "none";
        document.getElementById("image-bookmark").style.opacity = 0;
      }
    }

    function checkBookmarkThisPage(cfi) {
      if ((book.locations.epubcfi.compare(cfi, rendition.location.start.cfi) == 1 || book.locations.epubcfi.compare(cfi, rendition.location.start.cfi) == 0) &&
        (book.locations.epubcfi.compare(cfi, rendition.location.end.cfi) == -1 || book.locations.epubcfi.compare(cfi, rendition.location.end.cfi) == 0)) {
        return true;
      }
      else {
        return false;
      }
    }

    function removeNoteInNote(loc) {
      httpPost("removenote", {
        MemberNo: _memberNo,
        BookNo: _bookNo,
        NotePositionValue: loc,
      }).then(function (result) {
        if (result < 1) {
          alert("북마크 삭제 실패 관리자에게 문의바랍니다.");
        } else {
          rendition.annotations.remove(loc, "highlight");
        }
      })

    }


    //목차
    async function getChapter(useInvokeMethod = true) {
      var chapters = await book.loaded.navigation;
      var result = [];
      chapters.forEach((chapter) => {
        var item = {};
        item.href = chapter.href;
        item.label = chapter.label;
        let section = book.spine.get(chapter.href);
        let cfi = "epubcfi(" + section.cfiBase + "!/1/1)";
        let percentage = book.locations.percentageFromCfi(cfi);
        let page = book.locations.locationFromCfi(cfi);
        item.progress = percentage;
        item.page = page;
        item.cfi = chapter.href;
        item.isCurrent = false;
        result.push(item);
        if (chapter.subitems.length > 0) {
          for (let i = 0; i < chapter.subitems.length; i++) {
            item = {};
            item.href = chapter.subitems[i].href;
            item.label = chapter.subitems[i].label;
            section = book.spine.get(chapter.subitems[i].href);
            cfi = "epubcfi(" + section.cfiBase + "!/1/1)";
            percentage = book.locations.percentageFromCfi(cfi);
            page = book.locations.locationFromCfi(cfi);
            item.progress = percentage;
            item.page = page;
            item.cfi = chapter.subitems[i].href;
            item.firstDepth = true;
            item.isCurrent = false;
            result.push(item);

            if (chapter.subitems[i].subitems.length > 0) {
              for (let j = 0; j < chapter.subitems[i].subitems[j].length; i++) {
                item = {};
                item.href = chapter.subitems[i].subitems[j].href;
                item.label = chapter.subitems[i].subitems[j].label;
                section = book.spine.get(chapter.subitems[i].subitems[j].href);
                cfi = "epubcfi(" + section.cfiBase + "!/1/1)";
                percentage = book.locations.percentageFromCfi(cfi);
                page = book.locations.locationFromCfi(cfi);
                item.progress = percentage;
                item.page = page;
                item.cfi = chapter.subitems[i].subitems[j].href;
                item.isCurrent = false;
                result.push(item);
              }
            }
          }
        }
      })
      // 김형도 수정
      if (useInvokeMethod) {
        getCurrentChapter().then(function (data) {
          result[data.order].isCurrent = true;
          invokeCSharpAction('{"func": "SetChapters", "params": ' + JSON.stringify(result) + '}');
        })
      }
      return result;
    }

    async function getCurrentChapter() {
      let chapterList = await getChapter(false);
      for (let i = 0; i < chapterList.length; i++) {
        let section = book.spine.get(chapterList[i].cfi);
        let sectionCfi = "epubcfi(" + section.cfiBase + "!/1/0/0)";
        if (rendition.location && book.locations.epubcfi.compare(rendition.location.start.cfi, sectionCfi) <= 0) {
          return { chapterInfo: chapterList[i - 1], order: i - 1 };
        }
      }
      return { chapterInfo: chapterList[chapterList.length - 1], order: chapterList.length - 1 };
    }
    //#endregion

    // CFI 이동 - 추가
    function moveToHRef(cfi) {
      prevClick = false;
      rendition.display(cfi);
    }

    function highlightFindText(cfi) {
      window.setTimeout(function () {
        rendition.annotations.add(
          "highlight",
          cfi,
          undefined,
          undefined,
          undefined,
          undefined,
          "black"
        );
      }, 500);
      window.setTimeout(function () {
        rendition.annotations.remove(cfi, "highlight");
        const index = rendition.annotations.highlights.indexOf(cfi);
        if (index > -1) {
          rendition.annotations.highlights.splice(index, 1);
        }
      }, 5000);
    }

    //0728
    function changingProgressBar(progressBarValue, progressBarMaxValue) {
      let currentCfi
      if (typeof progressBarMaxValue == "undefined") {
        currentCfi = book.locations.cfiFromPercentage(progressBarValue);
      }
      else if (progressBarMaxValue > 1) {
        currentCfi = book.locations.cfiFromPercentage(progressBarValue / progressBarMaxValue);
      }

      let spineItem = book.spine.get(currentCfi);
      let navItem = book.navigation.get(spineItem.href);

      let chapter = {};
      chapter.label = "";
      if (navItem) {
        chapter.label = navItem.label;
      }
      else {
        while (spineItem.prev()) {
          spineItem = spineItem.prev();
          navItem = book.navigation.get(spineItem.href);
          if (navItem) {
            chapter.label = navItem.label;
            break;
          }
        }
      }
      if (typeof progressBarMaxValue == "undefined") {
        chapter.progress = progressBarValue;
      }
      else if (progressBarMaxValue > 1) {
        chapter.progress = progressBarValue / progressBarMaxValue;
      }

      return chapter;
    }
    function changedProgressBar(progressBarValue) {
      if (progressBarValue == 0) {
        rendition.display();
      }
      // else if (progressBarValue == rendition.book.locations.total) {
      //   rendition.display(book.locations._locations[progressBarValue]).then(() => {
      //     window.setTimeout(() => {
      //       swipeRight();
      //     }, 500)

      //   });
      // }
      else {
        rendition.display(book.locations._locations[progressBarValue]);
      }
    }

    //#region 페이지 자동 넘김
    let relocatedHandler = () => {
      if (iosChecker == true) {
        const container = document.getElementsByClassName("epub-container")[0];
        if ((container.ready == false || container.ready == undefined)) {
          container.ready = true;
          if (container.moveType == undefined) return;
          let scrollLastValue;
          if (container.moveType == true) {
            scrollLastValue = container.scrollHeight - document.documentElement.clientHeight - document.documentElement.clientHeight * 4 / 10;
            if (scrollLastValue < 0) {
              scrollLastValue = document.documentElement.clientHeight * 4 / 10;
            }
            scrollLastValue = scrollLastValue;
            container.moveType = undefined;
          }
          else if (container.moveType == false) {
            scrollLastValue = document.documentElement.clientHeight * 4 / 10;
            container.moveType = undefined;
          }

          container.scrollTo(0, scrollLastValue);
          setTimeout(function () {
            document.getElementById("div-loading").classList.remove("show");
          }, 100)
        }
      }
    }

    let relocateAllow = true;
    let scrollHandler = function (e) {
      if (this.resizeStart == true) {
        this.resizeStart = false;
        return;
      }
      //너무 바른 페이지 이동 막기 ios 오토플립
      if (!relocateAllow) return;

      if (iosChecker) {
        if (this.scrollTop <= 0 && this.ready) {
          if (rendition.location.start.index != 0) {
            document.getElementById("div-loading").classList.add("show");
            document.getElementById("div-loading").focus();
            this.ready = false;
            this.moveType = true;
            swipeLeft();
          }
        }
        else if ((document.documentElement.clientHeight + this.scrollTop) >= this.scrollHeight && this.ready) {
          if ((book.spine.spineItems.length - 1 != rendition.location.start.index)) {
            document.getElementById("div-loading").classList.add("show");
            document.getElementById("div-loading").focus();
            this.ready = false;
            this.moveType = false;
            swipeRight();
          }
          else {
            invokeCSharpAction('{"func": "LastPageAlert", "params":' + JSON.stringify([{ CompleteReadYN: _completeReadYN }]) + '}');
          }
        }
        else {
          if (this.ready == true)
            this.moveType = undefined;
        }
      }

    }
    function pageAutoFlipOn() {
      const container = document.getElementsByClassName("epub-container")[0];
      container.addEventListener("scroll", scrollHandler, false)
      rendition.on("relocated", relocatedHandler);
      container.classList.add("ios-container");
    }

    function pageAutoFlipOff() {
      const container = document.getElementsByClassName("epub-container")[0];
      rendition.off("relocated", relocatedHandler);
      container.removeEventListener("scroll", scrollHandler);
      container.classList.remove("ios-container");
      container.ready = true;
    }

    function removeTopBottomArrow(){
       let parent = document.getElementsByClassName("epub-view")[0]?.parentElement;

        let imgs = [];
       for(let item of parent.childNodes){
        if(item.tagName == "IMG")
         imgs.push(item);
         
       }
       for(let item of imgs){
        parent.removeChild(item);
       }
        
    }
    //#endregion

    //#region hypothesis 위치 
    function getPopupLocation() {
      let contents = rendition.getContents();
      let locations = [];
      for (var i = 0; i < contents.length; i++) {
        let hypothesisAdder = contents[i].document.getElementsByTagName("hypothesis-adder")[0];
        let location = {};
        location.left = hypothesisAdder.offsetLeft;
        location.top = hypothesisAdder.offsetTop;
        location.width = hypothesisAdder.shadowRoot.children[0].offsetWidth;
        location.height = hypothesisAdder.shadowRoot.children[0].offsetHeight;
        locations.push(location);
      }
      return locations;
    }
    //#endregion

    //#region 터치이벤트
    const leftRightTouch = function (contents) {
      contents.window.addEventListener("click", leftRightTouchHandler)
    };
    const leftRightTouchHandler = function (e) {
      if (this.getSelection().type == "Range") {
        return;
      }

      let modals = document.getElementsByClassName("modal-highlight");
      for (let i = 0; i < modals.length; i++) {
        if (modals[i].style.display != "none") {
          adder.hide();
          modifier.hide();
          return;
        }
      }
      let documentHeight = viewer.clientHeight;
      let documentWidth = viewer.clientWidth;
      let nextArea = documentWidth - documentWidth * 3 / 10;
      let prevArea = documentWidth * 3 / 10;
      if (viewer.classList.contains("scroll")) {
        // 김형도 추가
        invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
      }
      else {
        if (e.screenX > nextArea) {
          swipeRight();
        }
        else if (e.screenX < prevArea) {
          swipeLeft();
        }
        else {

          // if (ttt) {
          // ttt = false;
          // viewChange("both");
          // registerTouch(true, "reverse");
          // alert("both");
          // alert(rendition.views()._views[0].settings.layout._spread);
          // }
          // else {
          // ttt = true;
          // viewChange("none");
          // scrollingChange("scolled");
          // registerTouch(true, "nextOnly");
          // alert("none");
          // alert(rendition.views()._views[0].settings.layout._spread);
          // }
          // 김형도 추가
          invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
        }
      }
    };

    const leftRightReverseTouch = function (contents) {
      contents.window.addEventListener("click", leftRightReverseTouchHandler)
    };
    const leftRightReverseTouchHandler = function (e) {
      if (this.getSelection().type == "Range") {
        return;
      }

      let modals = document.getElementsByClassName("modal-highlight");
      for (let i = 0; i < modals.length; i++) {
        if (modals[i].style.display != "none") {
          adder.hide();
          modifier.hide();
          return;
        }
      }
      let documentHeight = viewer.clientHeight;
      let documentWidth = viewer.clientWidth;
      let nextArea = documentWidth - documentWidth * 3 / 10;
      let prevArea = documentWidth * 3 / 10;
      if (viewer.classList.contains("scroll")) {
        // 김형도 추가
        invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
      }
      else {
        if (e.screenX > nextArea) {
          swipeLeft();

        }
        else if (e.screenX < prevArea) {
          swipeRight();
        }
        else {
          // if (ttt) {
          // viewChange("both");
          // registerTouch(true, "reverse");
          // ttt = false;
          // alert("both");
          // alert(rendition.views()._views[0].settings.layout._spread);
          // }
          // else {
          // registerTouch(true, "nextOnly");
          // ttt = true;
          // alert("none");
          // alert(rendition.views()._views[0].settings.layout._spread);

          // }

          // 김형도 추가
          invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
        }
      }
    };


    const leftRightOnlyNextTouch = function (contents) {
      contents.window.addEventListener("click", leftRightOnlyNextTouchHandler)
    };
    const leftRightOnlyNextTouchHandler = function (e) {
      if (this.getSelection().type == "Range") {
        return;
      }

      let modals = document.getElementsByClassName("modal-highlight");
      for (let i = 0; i < modals.length; i++) {
        if (modals[i].style.display != "none") {
          adder.hide();
          modifier.hide();
          return;
        }
      }
      let documentHeight = viewer.clientHeight;
      let documentWidth = viewer.clientWidth;
      let nextArea = documentWidth - documentWidth * 3 / 10;
      let prevArea = documentWidth * 3 / 10;
      if (viewer.classList.contains("scroll")) {
        // 김형도 추가
        invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
      }
      else {
        if (e.screenX > nextArea) {
          swipeRight();

        }
        else if (e.screenX < prevArea) {
          swipeRight();
        }
        else {

          // if (ttt) {
          // viewChange("both");
          // registerTouch(true, "reverse");
          // ttt = false;
          // alert("both");
          // alert(rendition.views()._views[0].settings.layout._spread);
          // }
          // else {
          // registerTouch(true, "nextOnly");
          // ttt = true;
          // alert("none");
          // alert(rendition.views()._views[0].settings.layout._spread);

          // 김형도 추가
          invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
        }

      }

    };

    const topBottomTouch = function (contents) {
      contents.window.addEventListener("click", topBottomTouchHandler)
    };
    const topBottomTouchHandler = function (e) {
      if (this.getSelection().type == "Range") {
        return;
      }

      let modals = document.getElementsByClassName("modal-highlight");
      for (let i = 0; i < modals.length; i++) {
        if (modals[i].style.display != "none") {
          adder.hide();
          modifier.hide();
          return;
        }
      }
      let documentHeight = viewer.clientHeight;
      let documentWidth = viewer.clientWidth;
      let nextArea = documentHeight - documentHeight * 3 / 10;
      let prevArea = documentHeight * 3 / 10;
      if (viewer.classList.contains("scroll")) {
        // 김형도 추가
        invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');

      }
      else {
        if (e.screenY > nextArea) {
          swipeRight();

        }
        else if (e.screenY < prevArea) {
          swipeLeft();
        }
        else {
          // 김형도 추가
          invokeCSharpAction('{"func": "ShowMenuToggle", "params": null}');
        }
      }
    };



    function registerTouch(identifier, type = "normal") {
      deregisterTouch();

      if (identifier == true) {
        if (type == "normal") {
          book.rendition.hooks.content.register(leftRightTouch);
        }
        else if (type == "reverse") {
          book.rendition.hooks.content.register(leftRightReverseTouch);
        }
        else if (type == "nextOnly") {
          book.rendition.hooks.content.register(leftRightOnlyNextTouch);
        }
      }
      else if (identifier == false) {
        book.rendition.hooks.content.register(topBottomTouch);
      }
      if (rendition && rendition.views && rendition.views()._views) {
        const les = rendition.views()._views.length;
        if (les) {
          for (let i = 0; i < les; i++) {
            book.rendition.hooks.content.trigger(rendition.views()._views[i]);
          }
        }
      }


    }

    function deregisterTouch() {
      book.rendition.hooks.content.deregister(leftRightTouch);
      book.rendition.hooks.content.deregister(topBottomTouch);
      book.rendition.hooks.content.deregister(leftRightReverseTouch);
      book.rendition.hooks.content.deregister(leftRightOnlyNextTouch);

      book.rendition.hooks.content.deregister(leftRightTouchHandler);
      book.rendition.hooks.content.deregister(topBottomTouchHandler);
      book.rendition.hooks.content.deregister(leftRightReverseTouchHandler);
      book.rendition.hooks.content.deregister(leftRightOnlyNextTouchHandler);

      if (rendition.views()._views) {
        for (let i = 0; i < rendition.views()._views.length; i++) {
          if (rendition.views()._views[i].window) {
            rendition.views()._views[i].window.removeEventListener("click", leftRightTouch);
            rendition.views()._views[i].window.removeEventListener("click", topBottomTouch);
            rendition.views()._views[i].window.removeEventListener("click", leftRightReverseTouch);
            rendition.views()._views[i].window.removeEventListener("click", leftRightOnlyNextTouch);

            rendition.views()._views[i].window.removeEventListener("click", leftRightTouchHandler);
            rendition.views()._views[i].window.removeEventListener("click", topBottomTouchHandler);
            rendition.views()._views[i].window.removeEventListener("click", leftRightReverseTouchHandler);
            rendition.views()._views[i].window.removeEventListener("click", leftRightOnlyNextTouchHandler);
          }
        }
      }
    }
    //#endregion

    //#region 챕터이동
    function prevChapter() {
      getChapter(false).then(function (chapterList) {
        for (let i = 0; i < chapterList.length; i++) {
          let section = book.spine.get(chapterList[i].cfi);
          let sectionCfi = "epubcfi(" + section.cfiBase + "!/0/0/0)";
          if (rendition.location && book.locations.epubcfi.compare(rendition.location.end.cfi, sectionCfi) <= 0) {
            rendition.display(chapterList[i - 2].cfi).then(() => {
              if (viewer.classList.contains("scroll") && iosChecker) {
                document.getElementsByClassName("epub-container")[0].scrollTo(0, document.documentElement.clientHeight * 4 / 10 - 10);
              }

            });;
            return;
          }
        }
        rendition.display(chapterList[chapterList.length - 2].cfi).then(() => {
          if (viewer.classList.contains("scroll") && iosChecker) {
            document.getElementsByClassName("epub-container")[0].scrollTo(0, document.documentElement.clientHeight * 4 / 10 - 10);
          }
        });;
      });
    }

    function nextChapter() {
      getChapter(false).then(function (chapterList) {
        for (let i = 0; i < chapterList.length; i++) {
          let section = book.spine.get(chapterList[i].cfi);
          let sectionCfi = "epubcfi(" + section.cfiBase + "!/0/0/0)"
          if (rendition.location && book.locations.epubcfi.compare(rendition.location.end.cfi, sectionCfi) <= 0) {
            rendition.display(chapterList[i].cfi).then(() => {
              if (viewer.classList.contains("scroll") && iosChecker) {
                document.getElementsByClassName("epub-container")[0].scrollTo(0, document.documentElement.clientHeight * 4 / 10 - 10);
              }
            });
            break;
          }
        }
      });
    }
    //#endregion


    //#region 뷰포트 변경
    function changeViewport(isUserScale) {
      let viewport = document.head.querySelector("meta[name=viewport]");

      let content;
      if (!viewport) {
        viewport = document.createElement("meta");
        viewport.name = "viewport";
        document.getElementsByTagName("head")[0].appendChild(viewport);
      }
      if (isUserScale) {
        content = "width=device-width, height=device-height, initial-scale=1, user-scalable=1, maximum-scale=3"
      }
      else {
        content = "width=device-width, height=device-height, initial-scale=1, user-scalable=0, maximum-scale=1"
      }
      viewport.setAttribute("content", content);


    }
    //#endregion

    function closeModal() {
      if (adder && adder.hide) adder.hide();
      if (modifier && modifier.hide) modifier.hide();
    }

    let currentRepColor = "#FFEDA8";

    function highlightComplete(targetText, color) {
      targetText = decodeURIComponent(targetText);
      rendition.annotations.highlight(adder.cfi,
        { memo: false },
        undefined,
        undefined,
        undefined,
        color);

      chapterFromCfi(adder.cfi).then(function (chapter) {
        httpPost("AddNote", {
          MemberNo: _memberNo, BookNo: _bookNo, NotePositionValue: adder.cfi,
          NoteHighlightColorKindcode: color, NoteText: "", NoteTableContent: targetText,
          NotePercentage: Math.round(
            book.locations.percentageFromCfi(adder.cfi) * 100
          ),
          TableContentName: chapter.chapter,
          TableContentNameSub: chapter.chapterParent,
        })
      })
    }

    function addMemoComplete(text, note) {
      let noteText = "";
      let noteTableContent = "";
      if (text) {
        noteTableContent = decodeURIComponent(text);
      }

      if (note) {
        noteText = decodeURIComponent(note);
      }
      chapterFromCfi(adder.cfi).then((chapter) => {
        httpPost("addnote", {
          MemberNo: _memberNo,
          BookNo: _bookNo,
          NotePositionValue: adder.cfi,
          NoteText: noteText,
          NoteTableContent: noteTableContent,
          NoteHighlightColorKindcode: "#FFEDA8",
          NotePage: 1,
          NotePercentage: Math.round(
            book.locations.percentageFromCfi(adder.cfi) * 100
          ),
          TableContentName: chapter.chapter,
          TableContentNameSub: chapter.chapterParent,
        }).then(function (result) {
          if (result < 1) {
            alert("메모등록 실패 관리자에게 문의바랍니다.");
          }
        })
      });
      if (!rendition.annotations.highlights.includes(adder.cfi)) {
        rendition.annotations.highlight(
          adder.cfi,
          { memo: true },
          undefined,
          undefined,
          undefined,
          currentRepColor
        );
      }
    }

    function modifyMemoComplete(cfi, memo, color) {
      let memoValue = "";
      if (memo) {
        memoValue = decodeURIComponent(memo);
      }
      httpPost("modifynote", {
        MemberNo: _memberNo,
        BookNo: _bookNo,
        NotePositionValue: cfi,
        NoteText: memoValue,
      }).then(function (result) {
        if (result < 1) {
          alert("메모등록 실패 관리자에게 문의바랍니다.");
        }
      })

      rendition.annotations.remove(cfi, "highlight");
      rendition.annotations.highlight(
        cfi,
        { memo: true },
        undefined,
        undefined,
        undefined,
        color
      );
    }

    //#endregion
    document.addEventListener("addHighlight", (e) => {
      rendition.annotations.highlight(
        e.detail.cfi,
        undefined,
        undefined,
        undefined,
        undefined,
        e.detail.color
      );
      chapterFromCfi(e.detail.cfi).then((chapter) => {
        httpPost("addnote", {
          MemberNo: _memberNo,
          BookNo: _bookNo,
          NotePositionValue: e.detail.cfi,
          NoteText: "",
          NoteTableContent: e.detail.text,
          NoteHighlightColorKindcode: e.detail.color,
          NotePage: 1,
          NotePercentage: Math.round(
            book.locations.percentageFromCfi(e.detail.cfi) * 100
          ),
          TableContentName: chapter.chapter,
          TableContentNameSub: chapter.chapterParent,
        }).then(function (result) {
          if (result < 1) {
            alert("메모 등록 실패 관리자에게 문의바랍니다.");
          }
        })
      });
    });
    document.addEventListener("removeHighlight", (e) => {
      rendition.annotations.remove(e.detail.cfi, "highlight");

      httpPost("removenote", {
        MemberNo: _memberNo,
        BookNo: _bookNo,
        NotePositionValue: e.detail.cfi,
      }).then(function (result) {
        if (result < 1) {
          alert("삭제 실패 관리자에게 문의바랍니다.");
        }
      })
    });

    document.addEventListener("modifyHighlight", (e) => {
      httpPost("modifynotecolor", {
        MemberNo: _memberNo,
        BookNo: _bookNo,
        NotePositionValue: e.detail.cfi,
        NoteHighlightColorKindcode: e.detail.color,
      }).then((result) => {
        if (result < 1) {
          alert("변경 실패 관리자에게 문의바랍니다.");
        }
      })

      rendition.annotations.remove(e.detail.cfi, "highlight");
      if (rendition.annotations.memos.includes(e.detail.cfi)) {
        rendition.annotations.highlight(
          e.detail.cfi,
          { memo: true },
          undefined,
          undefined,
          undefined,
          e.detail.color
        );
      } else {
        rendition.annotations.highlight(
          e.detail.cfi,
          undefined,
          undefined,
          undefined,
          undefined,
          e.detail.color
        );
      }
    });


    document.addEventListener("addMemo", (e) => {
      let percentage;
      percentage = book.locations.percentageFromCfi(e.detail.cfi);
      invokeCSharpAction('{"func": "AddMemo", "params": [{"Text": "' + e.detail.text + '", "Cfi": "' + e.detail.cfi + '", "Percentage" :"' + percentage + '"}]}');
    })
    document.addEventListener("modifyMemo", (e) => {
      httpGet("GetNoteByPosition", { MemberNo: _memberNo, BookNo: _bookNo, NotePositionValue: e.detail.cfi }).then(function (result) {
        modifier.cfi = e.detail.cfi;
        let percentage = book.locations.percentageFromCfi(e.detail.cfi);
        invokeCSharpAction('{"func": "ModifyMemo", "params": [{"Note": "' + result[0].NoteText + '", "Text" : "' + result[0].NoteTableContent + '", "Cfi": "' + e.detail.cfi + '", "Percentage" :"' + percentage + '", "ColorCode" : "' + result[0].NoteHighlightColorKindcode + '"}]}');
      })
    })
    document.addEventListener("shareContent", (e) => {
      // if (e.detail.text.length > 50) {
      //   alert("50자 이상 복사할 수 없습니다.");
      //   return;
      // }
      invokeCSharpAction('{"func": "ShareContent", "params": [{"Text" : "' + e.detail.text + '"}]}');
    })

    //#region 페이지 이동 저장
    var prevPage = [];
    let prevClick = false;
    let prevMethod;
    let term = false;
    document.addEventListener("pageMoveBefore", (e) => {
      if (!prevClick && !term) {
        prevMethod = window.setTimeout(function () {
          prevPage.push(e.detail.cfi);
          if (prevPage.length > 30) {
            prevPage.splice(0, 1);
          }
          term = false;
        }, 50)
        term = true;
      }

    });
    //#endregion


    function getNote() {
      httpGet("getnote", { "MemberNo": _memberNo, "BookNo": _bookNo }).then(function (result) {
        invokeCSharpAction(`{"func": "GetNote", "params": ${JSON.stringify(result)}}`)
      })
    }

    function modifyHighlightColor(cfi, color) {
      httpPost("modifynotecolor", {
        MemberNo: _memberNo,
        BookNo: _bookNo,
        NotePositionValue: cfi,
        NoteHighlightColorKindcode: color,
      }).then((result) => {
        if (result < 1) {
          alert("삭제 실패 관리자에게 문의바랍니다.");
        }
      })

      rendition.annotations.remove(cfi, "highlight");
      if (rendition.annotations.memos.includes(cfi)) {
        rendition.annotations.highlight(
          cfi,
          { memo: true },
          undefined,
          undefined,
          undefined,
          color
        );
      } else {
        rendition.annotations.highlight(
          cfi,
          undefined,
          undefined,
          undefined,
          undefined,
          color
        );
      }
    }

    document.addEventListener("reportEvent", function () {
      prevClick = true;
      rendition.reportLocation();
    })

    /* #region CSS 다이나믹 바인딩  */
    function getColorData() {
      httpGet("GetCommonCodeByCodeGroup", { GroupCode: "V01" }).then(function (colorData) {
        if (colorData && colorData.length > 0) {
          for (let i = 0; i < colorData.length; i++) {
            const style = document.createElement("style");
            style.type = "text/css";
            style.innerHTML = `.highlight-color-${(i + 1)} { border-color: ${colorData[i].ExtraField2}; background-color: ${colorData[i].ExtraField1};}`;
            document.head.appendChild(style);
          }
        }
        //#region adder 영역
        var textButtons = [];
        var textButton = {};
        textButton.text = "메모";
        textButtons.push(textButton);
        textButton = {};
        textButton.text = "공유";
        textButtons.push(textButton);
        adder = new Adder(textButtons, "adder");
        //endregion
        //#region modifier 영역
        textButtons = [];
        textButton = {};
        textButton.text = "삭제";
        textButtons.push(textButton);
        textButton = {};
        textButton.text = "메모 수정";
        textButtons.push(textButton);
        modifier = new Adder(textButtons, "modifier");
        //#endregion

      })

      //#region adder 영역
      var textButtons = [];
      var textButton = {};
      textButton.text = "메모";
      textButtons.push(textButton);
      textButton = {};
      textButton.text = "공유";
      textButtons.push(textButton);
      adder = new Adder(textButtons, "adder");
      //endregion
      //#region modifier 영역
      textButtons = [];
      textButton = {};
      textButton.text = "삭제";
      textButtons.push(textButton);
      textButton = {};
      textButton.text = "메모 수정";
      textButtons.push(textButton);
      modifier = new Adder(textButtons, "modifier");
      //#endregion

    }
    getColorData();

    // function getBackgroundData(doc) {
    //   for (let i = 1; i <= 6; i++) {
    //     httpGet("GetValueByCode", { GroupCode: "V02", Code: "00" + i }).then(function (data) {
    //       if (i < 4) {
    //         const style = document.createElement("style");
    //         style.innerHTML = `.${data[0].value} {background-color : ${data[0].backgroundColor}; color : ${data[0].order};
    //       border-color:${data[0].borderColor};}`;
    //         doc.head.appendChild(style);
    //       }
    //       else {
    //         const style = document.createElement("style");
    //         style.innerHTML = `.${data[0].value},  .${data[0].value} *:not(svg) {background-color : ${data[0].backgroundColor}; color : ${data[0].order};
    //       border-color:${data[0].borderColor};}`;
    //         doc.head.appendChild(style);
    //       }

    //     })
    //   }
    // }
    // getBackgroundData(document);
    /* #endregion */

    // function removeSelectArea() {
    //   book.rendition.hooks.content.register((contents) => {
    //     contents.window.addEventListener("removeSelection", () => {
    //       contents.document.getSelection().removeAllRanges();
    //     })
    //   })
    // }

    function changePrevClick(indicator) {
      if (indicator) {
        prevClick = true;
      }
      else if (!indicator) {
        prevClick = false;
      }

    }

    //마지막페이지 이벤트....=======================
    document.addEventListener("lastPage", () => {
      invokeCSharpAction('{"func": "LastPageAlert", "params":' + JSON.stringify([{ CompleteReadYN: _completeReadYN }]) + '}');
    })

    function modifyCompleteRead() {
      httpPost("ModifyCompleteRead", { ContentNo: _contentNo, MemberNo: _memberNo }).then(function (data) {
        if (data > 0) {
          _completeReadYN = "Y";
        }
      })
    }

    //마지막 페이지 이벤트 =========================

    //앱에서 북마크 지웠을 때 웹도 업데이트를 해야함========
    function updateBookmarkList() {
      httpGet("getbookmark", { BookNo: _bookNo, MemberNo: _memberNo }).then(function (bookmark) {
        bookmarkList = [];
        for (let i = 0; i < bookmark.length; i++) {
          bookmark[i].cfi = bookmark[i].BookMarkPositionValue;
          bookmarkList.push(bookmark[i]);
        }
      })
    }
    //================================================


    //이벤트 테스트
      

    //
        </script>
    </body>
</html>
